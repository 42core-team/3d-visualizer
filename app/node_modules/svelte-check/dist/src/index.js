'use strict';

var require$$0$5 = require('chokidar');
var require$$0$1 = require('fs');
var path$1 = require('path');
var require$$0$2 = require('node:util');
var require$$1$2 = require('util');
var require$$2$1 = require('os');
var require$$3 = require('crypto');
var require$$4 = require('net');
var require$$5 = require('url');
var require$$3$1 = require('child_process');
var require$$0$3 = require('events');
var ts = require('typescript');
var require$$1$3 = require('fs/promises');
var require$$0$4 = require('@jridgewell/trace-mapping');
var compiler = require('svelte/compiler');
var require$$1$4 = require('perf_hooks');
var sade = require('sade');
var pc = require('picocolors');

function _interopNamespaceDefault(e) {
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n.default = e;
	return Object.freeze(n);
}

var require$$0__namespace = /*#__PURE__*/_interopNamespaceDefault(require$$0$1);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path$1);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var dist = {};

var builder = {};

var apiBuilder = {};

var async = {};

var walker = {};

var utils$6 = {};

Object.defineProperty(utils$6, "__esModule", { value: true });
utils$6.convertSlashes = utils$6.cleanPath = void 0;
const path_1$g = path$1;
function cleanPath(path) {
    let normalized = (0, path_1$g.normalize)(path);
    if (normalized.length > 1 && normalized[normalized.length - 1] === path_1$g.sep)
        normalized = normalized.substring(0, normalized.length - 1);
    return normalized;
}
utils$6.cleanPath = cleanPath;
const SLASHES_REGEX = /[\\/]/g;
function convertSlashes(path, separator) {
    return path.replace(SLASHES_REGEX, separator);
}
utils$6.convertSlashes = convertSlashes;

var joinPath$4 = {};

Object.defineProperty(joinPath$4, "__esModule", { value: true });
joinPath$4.build = joinPath$4.joinDirectoryPath = void 0;
function joinPathWithBasePath(filename, directoryPath) {
    return directoryPath + filename;
}
function joinPathWithRelativePath(root) {
    return function (filename, directoryPath) {
        return directoryPath.substring(root.length) + filename;
    };
}
function joinPath$3(filename) {
    return filename;
}
function joinDirectoryPath(filename, directoryPath, separator) {
    return directoryPath + filename + separator;
}
joinPath$4.joinDirectoryPath = joinDirectoryPath;
function build$7(root, options) {
    const { relativePaths, includeBasePath } = options;
    return relativePaths && root
        ? joinPathWithRelativePath(root)
        : includeBasePath
            ? joinPathWithBasePath
            : joinPath$3;
}
joinPath$4.build = build$7;

var pushDirectory$2 = {};

Object.defineProperty(pushDirectory$2, "__esModule", { value: true });
pushDirectory$2.build = void 0;
function pushDirectoryWithRelativePath(root) {
    return function (directoryPath, paths) {
        paths.push((directoryPath || ".").substring(root.length));
    };
}
function pushDirectoryFilterWithRelativePath(root) {
    return function (directoryPath, paths, filters) {
        const relativePath = directoryPath.substring(root.length);
        if (filters.every((filter) => filter(relativePath, true))) {
            paths.push(relativePath);
        }
    };
}
const pushDirectory$1 = (directoryPath, paths) => {
    paths.push(directoryPath || ".");
};
const pushDirectoryFilter = (directoryPath, paths, filters) => {
    if (filters.every((filter) => filter(directoryPath, true))) {
        paths.push(directoryPath);
    }
};
const empty$2 = () => { };
function build$6(root, options) {
    const { includeDirs, filters, relativePaths } = options;
    if (!includeDirs)
        return empty$2;
    if (relativePaths)
        return filters && filters.length
            ? pushDirectoryFilterWithRelativePath(root)
            : pushDirectoryWithRelativePath(root);
    return filters && filters.length ? pushDirectoryFilter : pushDirectory$1;
}
pushDirectory$2.build = build$6;

var pushFile$2 = {};

Object.defineProperty(pushFile$2, "__esModule", { value: true });
pushFile$2.build = void 0;
const pushFileFilterAndCount = (filename, _paths, counts, filters) => {
    if (filters.every((filter) => filter(filename, false)))
        counts.files++;
};
const pushFileFilter = (filename, paths, _counts, filters) => {
    if (filters.every((filter) => filter(filename, false)))
        paths.push(filename);
};
const pushFileCount = (_filename, _paths, counts, _filters) => {
    counts.files++;
};
const pushFile$1 = (filename, paths) => {
    paths.push(filename);
};
const empty$1 = () => { };
function build$5(options) {
    const { excludeFiles, filters, onlyCounts } = options;
    if (excludeFiles)
        return empty$1;
    if (filters && filters.length) {
        return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
    }
    else if (onlyCounts) {
        return pushFileCount;
    }
    else {
        return pushFile$1;
    }
}
pushFile$2.build = build$5;

var getArray$2 = {};

Object.defineProperty(getArray$2, "__esModule", { value: true });
getArray$2.build = void 0;
const getArray$1 = (paths) => {
    return paths;
};
const getArrayGroup = () => {
    return [""].slice(0, 0);
};
function build$4(options) {
    return options.group ? getArrayGroup : getArray$1;
}
getArray$2.build = build$4;

var groupFiles$2 = {};

Object.defineProperty(groupFiles$2, "__esModule", { value: true });
groupFiles$2.build = void 0;
const groupFiles$1 = (groups, directory, files) => {
    groups.push({ directory, files, dir: directory });
};
const empty = () => { };
function build$3(options) {
    return options.group ? groupFiles$1 : empty;
}
groupFiles$2.build = build$3;

var resolveSymlink$1 = {};

var __importDefault$u = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(resolveSymlink$1, "__esModule", { value: true });
resolveSymlink$1.build = void 0;
const fs_1$4 = __importDefault$u(require$$0$1);
const resolveSymlinksAsync = function (path, state, callback) {
    const { queue, options: { suppressErrors }, } = state;
    queue.enqueue();
    fs_1$4.default.realpath(path, (error, resolvedPath) => {
        if (error) {
            queue.dequeue(suppressErrors ? null : error, state);
            return;
        }
        fs_1$4.default.lstat(resolvedPath, (_error, stat) => {
            callback(stat, resolvedPath);
            queue.dequeue(null, state);
        });
    });
};
const resolveSymlinksSync = function (path, state, callback) {
    try {
        const resolvedPath = fs_1$4.default.realpathSync(path);
        const stat = fs_1$4.default.lstatSync(resolvedPath);
        callback(stat, resolvedPath);
    }
    catch (e) {
        if (!state.options.suppressErrors)
            throw e;
    }
};
function build$2(options, isSynchronous) {
    if (!options.resolveSymlinks)
        return null;
    return isSynchronous ? resolveSymlinksSync : resolveSymlinksAsync;
}
resolveSymlink$1.build = build$2;

var invokeCallback$1 = {};

Object.defineProperty(invokeCallback$1, "__esModule", { value: true });
invokeCallback$1.build = void 0;
const onlyCountsSync = (state) => {
    return state.counts;
};
const groupsSync = (state) => {
    return state.groups;
};
const defaultSync = (state) => {
    return state.paths;
};
const limitFilesSync = (state) => {
    return state.paths.slice(0, state.options.maxFiles);
};
const onlyCountsAsync = (state, error, callback) => {
    report(error, callback, state.counts, state.options.suppressErrors);
    return null;
};
const defaultAsync = (state, error, callback) => {
    report(error, callback, state.paths, state.options.suppressErrors);
    return null;
};
const limitFilesAsync = (state, error, callback) => {
    report(error, callback, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
    return null;
};
const groupsAsync = (state, error, callback) => {
    report(error, callback, state.groups, state.options.suppressErrors);
    return null;
};
function report(error, callback, output, suppressErrors) {
    if (error && !suppressErrors)
        callback(error, output);
    else
        callback(null, output);
}
function build$1(options, isSynchronous) {
    const { onlyCounts, group, maxFiles } = options;
    if (onlyCounts)
        return isSynchronous
            ? onlyCountsSync
            : onlyCountsAsync;
    else if (group)
        return isSynchronous
            ? groupsSync
            : groupsAsync;
    else if (maxFiles)
        return isSynchronous
            ? limitFilesSync
            : limitFilesAsync;
    else
        return isSynchronous
            ? defaultSync
            : defaultAsync;
}
invokeCallback$1.build = build$1;

var walkDirectory$1 = {};

var __importDefault$t = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(walkDirectory$1, "__esModule", { value: true });
walkDirectory$1.build = void 0;
const fs_1$3 = __importDefault$t(require$$0$1);
const readdirOpts = { withFileTypes: true };
const walkAsync = (state, directoryPath, currentDepth, callback) => {
    state.queue.enqueue();
    if (currentDepth < 0) {
        state.queue.dequeue(null, state);
        return;
    }
    state.counts.directories++;
    fs_1$3.default.readdir(directoryPath || ".", readdirOpts, function process(error, entries = []) {
        callback(entries, directoryPath, currentDepth);
        state.queue.dequeue(state.options.suppressErrors ? null : error, state);
    });
};
const walkSync = (state, directoryPath, currentDepth, callback) => {
    if (currentDepth < 0) {
        return;
    }
    state.counts.directories++;
    let entries = [];
    try {
        entries = fs_1$3.default.readdirSync(directoryPath || ".", readdirOpts);
    }
    catch (e) {
        if (!state.options.suppressErrors)
            throw e;
    }
    callback(entries, directoryPath, currentDepth);
};
function build(isSynchronous) {
    return isSynchronous ? walkSync : walkAsync;
}
walkDirectory$1.build = build;

var queue = {};

Object.defineProperty(queue, "__esModule", { value: true });
queue.Queue = void 0;
class Queue {
    onQueueEmpty;
    count = 0;
    constructor(onQueueEmpty) {
        this.onQueueEmpty = onQueueEmpty;
    }
    enqueue() {
        this.count++;
    }
    dequeue(error, output) {
        if (--this.count === 0 || error)
            this.onQueueEmpty(error, output);
    }
}
queue.Queue = Queue;

var counter = {};

Object.defineProperty(counter, "__esModule", { value: true });
counter.Counter = void 0;
class Counter {
    _files = 0;
    _directories = 0;
    set files(num) {
        this._files = num;
    }
    get files() {
        return this._files;
    }
    set directories(num) {
        this._directories = num;
    }
    get directories() {
        return this._directories;
    }
    get dirs() {
        return this._directories;
    }
}
counter.Counter = Counter;

var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(walker, "__esModule", { value: true });
walker.Walker = void 0;
const path_1$f = path$1;
const utils_1$M = utils$6;
const joinPath$2 = __importStar$1(joinPath$4);
const pushDirectory = __importStar$1(pushDirectory$2);
const pushFile = __importStar$1(pushFile$2);
const getArray = __importStar$1(getArray$2);
const groupFiles = __importStar$1(groupFiles$2);
const resolveSymlink = __importStar$1(resolveSymlink$1);
const invokeCallback = __importStar$1(invokeCallback$1);
const walkDirectory = __importStar$1(walkDirectory$1);
const queue_1 = queue;
const counter_1 = counter;
class Walker {
    root;
    isSynchronous;
    state;
    joinPath;
    pushDirectory;
    pushFile;
    getArray;
    groupFiles;
    resolveSymlink;
    walkDirectory;
    callbackInvoker;
    constructor(root, options, callback) {
        this.isSynchronous = !callback;
        this.callbackInvoker = invokeCallback.build(options, this.isSynchronous);
        this.state = {
            paths: [""].slice(0, 0),
            groups: [],
            counts: new counter_1.Counter(),
            options,
            queue: new queue_1.Queue((error, state) => this.callbackInvoker(state, error, callback)),
        };
        this.root = this.normalizePath(root);
        this.joinPath = joinPath$2.build(this.root, options);
        this.pushDirectory = pushDirectory.build(this.root, options);
        this.pushFile = pushFile.build(options);
        this.getArray = getArray.build(options);
        this.groupFiles = groupFiles.build(options);
        this.resolveSymlink = resolveSymlink.build(options, this.isSynchronous);
        this.walkDirectory = walkDirectory.build(this.isSynchronous);
    }
    start() {
        this.walkDirectory(this.state, this.root, this.state.options.maxDepth, this.walk);
        return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
    }
    normalizePath(path) {
        const { resolvePaths, normalizePath, pathSeparator } = this.state.options;
        const pathNeedsCleaning = (process.platform === "win32" && path.includes("/")) ||
            path.startsWith(".");
        if (resolvePaths)
            path = (0, path_1$f.resolve)(path);
        if (normalizePath || pathNeedsCleaning)
            path = (0, utils_1$M.cleanPath)(path);
        if (path === ".")
            return "";
        const needsSeperator = path[path.length - 1] !== pathSeparator;
        return (0, utils_1$M.convertSlashes)(needsSeperator ? path + pathSeparator : path, pathSeparator);
    }
    walk = (entries, directoryPath, depth) => {
        const { paths, options: { filters, resolveSymlinks, exclude, maxFiles, signal }, } = this.state;
        if ((signal && signal.aborted) || (maxFiles && paths.length > maxFiles))
            return;
        this.pushDirectory(directoryPath, paths, filters);
        const files = this.getArray(this.state.paths);
        for (let i = 0; i < entries.length; ++i) {
            const entry = entries[i];
            if (entry.isFile() || (entry.isSymbolicLink() && !resolveSymlinks)) {
                const filename = this.joinPath(entry.name, directoryPath);
                this.pushFile(filename, files, this.state.counts, filters);
            }
            else if (entry.isDirectory()) {
                let path = joinPath$2.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
                if (exclude && exclude(entry.name, path))
                    continue;
                this.walkDirectory(this.state, path, depth - 1, this.walk);
            }
            else if (entry.isSymbolicLink() && resolveSymlinks) {
                let path = joinPath$2.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
                this.resolveSymlink(path, this.state, (stat, resolvedPath) => {
                    if (stat.isDirectory()) {
                        resolvedPath = this.normalizePath(resolvedPath);
                        if (exclude && exclude(entry.name, resolvedPath))
                            return;
                        this.walkDirectory(this.state, resolvedPath, depth - 1, this.walk);
                    }
                    else {
                        this.pushFile(resolvedPath, files, this.state.counts, filters);
                    }
                });
            }
        }
        this.groupFiles(this.state.groups, directoryPath, files);
    };
}
walker.Walker = Walker;

Object.defineProperty(async, "__esModule", { value: true });
async.callback = async.promise = void 0;
const walker_1$1 = walker;
function promise(root, options) {
    return new Promise((resolve, reject) => {
        callback(root, options, (err, output) => {
            if (err)
                return reject(err);
            resolve(output);
        });
    });
}
async.promise = promise;
function callback(root, options, callback) {
    let walker = new walker_1$1.Walker(root, options, callback);
    walker.start();
}
async.callback = callback;

var sync$1 = {};

Object.defineProperty(sync$1, "__esModule", { value: true });
sync$1.sync = void 0;
const walker_1 = walker;
function sync(root, options) {
    const walker = new walker_1.Walker(root, options);
    return walker.start();
}
sync$1.sync = sync;

Object.defineProperty(apiBuilder, "__esModule", { value: true });
apiBuilder.APIBuilder = void 0;
const async_1 = async;
const sync_1 = sync$1;
class APIBuilder {
    root;
    options;
    constructor(root, options) {
        this.root = root;
        this.options = options;
    }
    withPromise() {
        return (0, async_1.promise)(this.root, this.options);
    }
    withCallback(cb) {
        (0, async_1.callback)(this.root, this.options, cb);
    }
    sync() {
        return (0, sync_1.sync)(this.root, this.options);
    }
}
apiBuilder.APIBuilder = APIBuilder;

var utils$5 = {};

var constants;
var hasRequiredConstants;
function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	const path = path$1;
	const WIN_SLASH = '\\\\/';
	const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
	const DOT_LITERAL = '\\.';
	const PLUS_LITERAL = '\\+';
	const QMARK_LITERAL = '\\?';
	const SLASH_LITERAL = '\\/';
	const ONE_CHAR = '(?=.)';
	const QMARK = '[^/]';
	const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
	const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
	const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
	const NO_DOT = `(?!${DOT_LITERAL})`;
	const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
	const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
	const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
	const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
	const STAR = `${QMARK}*?`;
	const POSIX_CHARS = {
	  DOT_LITERAL,
	  PLUS_LITERAL,
	  QMARK_LITERAL,
	  SLASH_LITERAL,
	  ONE_CHAR,
	  QMARK,
	  END_ANCHOR,
	  DOTS_SLASH,
	  NO_DOT,
	  NO_DOTS,
	  NO_DOT_SLASH,
	  NO_DOTS_SLASH,
	  QMARK_NO_DOT,
	  STAR,
	  START_ANCHOR
	};
	const WINDOWS_CHARS = {
	  ...POSIX_CHARS,
	  SLASH_LITERAL: `[${WIN_SLASH}]`,
	  QMARK: WIN_NO_SLASH,
	  STAR: `${WIN_NO_SLASH}*?`,
	  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
	  NO_DOT: `(?!${DOT_LITERAL})`,
	  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
	  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
	  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
	  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
	};
	const POSIX_REGEX_SOURCE = {
	  alnum: 'a-zA-Z0-9',
	  alpha: 'a-zA-Z',
	  ascii: '\\x00-\\x7F',
	  blank: ' \\t',
	  cntrl: '\\x00-\\x1F\\x7F',
	  digit: '0-9',
	  graph: '\\x21-\\x7E',
	  lower: 'a-z',
	  print: '\\x20-\\x7E ',
	  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
	  space: ' \\t\\r\\n\\v\\f',
	  upper: 'A-Z',
	  word: 'A-Za-z0-9_',
	  xdigit: 'A-Fa-f0-9'
	};
	constants = {
	  MAX_LENGTH: 1024 * 64,
	  POSIX_REGEX_SOURCE,
	  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
	  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
	  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
	  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
	  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
	  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
	  REPLACEMENTS: {
	    '***': '*',
	    '**/**': '**',
	    '**/**/**': '**'
	  },
	  CHAR_0: 48,
	  CHAR_9: 57,
	  CHAR_UPPERCASE_A: 65,
	  CHAR_LOWERCASE_A: 97,
	  CHAR_UPPERCASE_Z: 90,
	  CHAR_LOWERCASE_Z: 122,
	  CHAR_LEFT_PARENTHESES: 40,
	  CHAR_RIGHT_PARENTHESES: 41,
	  CHAR_ASTERISK: 42,
	  CHAR_AMPERSAND: 38,
	  CHAR_AT: 64,
	  CHAR_BACKWARD_SLASH: 92,
	  CHAR_CARRIAGE_RETURN: 13,
	  CHAR_CIRCUMFLEX_ACCENT: 94,
	  CHAR_COLON: 58,
	  CHAR_COMMA: 44,
	  CHAR_DOT: 46,
	  CHAR_DOUBLE_QUOTE: 34,
	  CHAR_EQUAL: 61,
	  CHAR_EXCLAMATION_MARK: 33,
	  CHAR_FORM_FEED: 12,
	  CHAR_FORWARD_SLASH: 47,
	  CHAR_GRAVE_ACCENT: 96,
	  CHAR_HASH: 35,
	  CHAR_HYPHEN_MINUS: 45,
	  CHAR_LEFT_ANGLE_BRACKET: 60,
	  CHAR_LEFT_CURLY_BRACE: 123,
	  CHAR_LEFT_SQUARE_BRACKET: 91,
	  CHAR_LINE_FEED: 10,
	  CHAR_NO_BREAK_SPACE: 160,
	  CHAR_PERCENT: 37,
	  CHAR_PLUS: 43,
	  CHAR_QUESTION_MARK: 63,
	  CHAR_RIGHT_ANGLE_BRACKET: 62,
	  CHAR_RIGHT_CURLY_BRACE: 125,
	  CHAR_RIGHT_SQUARE_BRACKET: 93,
	  CHAR_SEMICOLON: 59,
	  CHAR_SINGLE_QUOTE: 39,
	  CHAR_SPACE: 32,
	  CHAR_TAB: 9,
	  CHAR_UNDERSCORE: 95,
	  CHAR_VERTICAL_LINE: 124,
	  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
	  SEP: path.sep,
	  extglobChars(chars) {
	    return {
	      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
	      '?': { type: 'qmark', open: '(?:', close: ')?' },
	      '+': { type: 'plus', open: '(?:', close: ')+' },
	      '*': { type: 'star', open: '(?:', close: ')*' },
	      '@': { type: 'at', open: '(?:', close: ')' }
	    };
	  },
	  globChars(win32) {
	    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
	  }
	};
	return constants;
}

var hasRequiredUtils$2;
function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$5;
	hasRequiredUtils$2 = 1;
	(function (exports) {
		const path = path$1;
		const win32 = process.platform === 'win32';
		const {
		  REGEX_BACKSLASH,
		  REGEX_REMOVE_BACKSLASH,
		  REGEX_SPECIAL_CHARS,
		  REGEX_SPECIAL_CHARS_GLOBAL
		} = requireConstants();
		exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
		exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
		exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
		exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
		exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');
		exports.removeBackslashes = str => {
		  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
		    return match === '\\' ? '' : match;
		  });
		};
		exports.supportsLookbehinds = () => {
		  const segs = process.version.slice(1).split('.').map(Number);
		  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
		    return true;
		  }
		  return false;
		};
		exports.isWindows = options => {
		  if (options && typeof options.windows === 'boolean') {
		    return options.windows;
		  }
		  return win32 === true || path.sep === '\\';
		};
		exports.escapeLast = (input, char, lastIdx) => {
		  const idx = input.lastIndexOf(char, lastIdx);
		  if (idx === -1) return input;
		  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
		  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
		};
		exports.removePrefix = (input, state = {}) => {
		  let output = input;
		  if (output.startsWith('./')) {
		    output = output.slice(2);
		    state.prefix = './';
		  }
		  return output;
		};
		exports.wrapOutput = (input, state = {}, options = {}) => {
		  const prepend = options.contains ? '' : '^';
		  const append = options.contains ? '' : '$';
		  let output = `${prepend}(?:${input})${append}`;
		  if (state.negated === true) {
		    output = `(?:^(?!${output}).*$)`;
		  }
		  return output;
		};
	} (utils$5));
	return utils$5;
}

var scan_1;
var hasRequiredScan;
function requireScan () {
	if (hasRequiredScan) return scan_1;
	hasRequiredScan = 1;
	const utils = requireUtils$2();
	const {
	  CHAR_ASTERISK,
	  CHAR_AT,
	  CHAR_BACKWARD_SLASH,
	  CHAR_COMMA,
	  CHAR_DOT,
	  CHAR_EXCLAMATION_MARK,
	  CHAR_FORWARD_SLASH,
	  CHAR_LEFT_CURLY_BRACE,
	  CHAR_LEFT_PARENTHESES,
	  CHAR_LEFT_SQUARE_BRACKET,
	  CHAR_PLUS,
	  CHAR_QUESTION_MARK,
	  CHAR_RIGHT_CURLY_BRACE,
	  CHAR_RIGHT_PARENTHESES,
	  CHAR_RIGHT_SQUARE_BRACKET
	} = requireConstants();
	const isPathSeparator = code => {
	  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
	};
	const depth = token => {
	  if (token.isPrefix !== true) {
	    token.depth = token.isGlobstar ? Infinity : 1;
	  }
	};
	const scan = (input, options) => {
	  const opts = options || {};
	  const length = input.length - 1;
	  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
	  const slashes = [];
	  const tokens = [];
	  const parts = [];
	  let str = input;
	  let index = -1;
	  let start = 0;
	  let lastIndex = 0;
	  let isBrace = false;
	  let isBracket = false;
	  let isGlob = false;
	  let isExtglob = false;
	  let isGlobstar = false;
	  let braceEscaped = false;
	  let backslashes = false;
	  let negated = false;
	  let negatedExtglob = false;
	  let finished = false;
	  let braces = 0;
	  let prev;
	  let code;
	  let token = { value: '', depth: 0, isGlob: false };
	  const eos = () => index >= length;
	  const peek = () => str.charCodeAt(index + 1);
	  const advance = () => {
	    prev = code;
	    return str.charCodeAt(++index);
	  };
	  while (index < length) {
	    code = advance();
	    let next;
	    if (code === CHAR_BACKWARD_SLASH) {
	      backslashes = token.backslashes = true;
	      code = advance();
	      if (code === CHAR_LEFT_CURLY_BRACE) {
	        braceEscaped = true;
	      }
	      continue;
	    }
	    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
	      braces++;
	      while (eos() !== true && (code = advance())) {
	        if (code === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }
	        if (code === CHAR_LEFT_CURLY_BRACE) {
	          braces++;
	          continue;
	        }
	        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          if (scanToEnd === true) {
	            continue;
	          }
	          break;
	        }
	        if (braceEscaped !== true && code === CHAR_COMMA) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          if (scanToEnd === true) {
	            continue;
	          }
	          break;
	        }
	        if (code === CHAR_RIGHT_CURLY_BRACE) {
	          braces--;
	          if (braces === 0) {
	            braceEscaped = false;
	            isBrace = token.isBrace = true;
	            finished = true;
	            break;
	          }
	        }
	      }
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (code === CHAR_FORWARD_SLASH) {
	      slashes.push(index);
	      tokens.push(token);
	      token = { value: '', depth: 0, isGlob: false };
	      if (finished === true) continue;
	      if (prev === CHAR_DOT && index === (start + 1)) {
	        start += 2;
	        continue;
	      }
	      lastIndex = index + 1;
	      continue;
	    }
	    if (opts.noext !== true) {
	      const isExtglobChar = code === CHAR_PLUS
	        || code === CHAR_AT
	        || code === CHAR_ASTERISK
	        || code === CHAR_QUESTION_MARK
	        || code === CHAR_EXCLAMATION_MARK;
	      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
	        isGlob = token.isGlob = true;
	        isExtglob = token.isExtglob = true;
	        finished = true;
	        if (code === CHAR_EXCLAMATION_MARK && index === start) {
	          negatedExtglob = true;
	        }
	        if (scanToEnd === true) {
	          while (eos() !== true && (code = advance())) {
	            if (code === CHAR_BACKWARD_SLASH) {
	              backslashes = token.backslashes = true;
	              code = advance();
	              continue;
	            }
	            if (code === CHAR_RIGHT_PARENTHESES) {
	              isGlob = token.isGlob = true;
	              finished = true;
	              break;
	            }
	          }
	          continue;
	        }
	        break;
	      }
	    }
	    if (code === CHAR_ASTERISK) {
	      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
	      isGlob = token.isGlob = true;
	      finished = true;
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (code === CHAR_QUESTION_MARK) {
	      isGlob = token.isGlob = true;
	      finished = true;
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (code === CHAR_LEFT_SQUARE_BRACKET) {
	      while (eos() !== true && (next = advance())) {
	        if (next === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }
	        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
	          isBracket = token.isBracket = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          break;
	        }
	      }
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
	      negated = token.negated = true;
	      start++;
	      continue;
	    }
	    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
	      isGlob = token.isGlob = true;
	      if (scanToEnd === true) {
	        while (eos() !== true && (code = advance())) {
	          if (code === CHAR_LEFT_PARENTHESES) {
	            backslashes = token.backslashes = true;
	            code = advance();
	            continue;
	          }
	          if (code === CHAR_RIGHT_PARENTHESES) {
	            finished = true;
	            break;
	          }
	        }
	        continue;
	      }
	      break;
	    }
	    if (isGlob === true) {
	      finished = true;
	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }
	  }
	  if (opts.noext === true) {
	    isExtglob = false;
	    isGlob = false;
	  }
	  let base = str;
	  let prefix = '';
	  let glob = '';
	  if (start > 0) {
	    prefix = str.slice(0, start);
	    str = str.slice(start);
	    lastIndex -= start;
	  }
	  if (base && isGlob === true && lastIndex > 0) {
	    base = str.slice(0, lastIndex);
	    glob = str.slice(lastIndex);
	  } else if (isGlob === true) {
	    base = '';
	    glob = str;
	  } else {
	    base = str;
	  }
	  if (base && base !== '' && base !== '/' && base !== str) {
	    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
	      base = base.slice(0, -1);
	    }
	  }
	  if (opts.unescape === true) {
	    if (glob) glob = utils.removeBackslashes(glob);
	    if (base && backslashes === true) {
	      base = utils.removeBackslashes(base);
	    }
	  }
	  const state = {
	    prefix,
	    input,
	    start,
	    base,
	    glob,
	    isBrace,
	    isBracket,
	    isGlob,
	    isExtglob,
	    isGlobstar,
	    negated,
	    negatedExtglob
	  };
	  if (opts.tokens === true) {
	    state.maxDepth = 0;
	    if (!isPathSeparator(code)) {
	      tokens.push(token);
	    }
	    state.tokens = tokens;
	  }
	  if (opts.parts === true || opts.tokens === true) {
	    let prevIndex;
	    for (let idx = 0; idx < slashes.length; idx++) {
	      const n = prevIndex ? prevIndex + 1 : start;
	      const i = slashes[idx];
	      const value = input.slice(n, i);
	      if (opts.tokens) {
	        if (idx === 0 && start !== 0) {
	          tokens[idx].isPrefix = true;
	          tokens[idx].value = prefix;
	        } else {
	          tokens[idx].value = value;
	        }
	        depth(tokens[idx]);
	        state.maxDepth += tokens[idx].depth;
	      }
	      if (idx !== 0 || value !== '') {
	        parts.push(value);
	      }
	      prevIndex = i;
	    }
	    if (prevIndex && prevIndex + 1 < input.length) {
	      const value = input.slice(prevIndex + 1);
	      parts.push(value);
	      if (opts.tokens) {
	        tokens[tokens.length - 1].value = value;
	        depth(tokens[tokens.length - 1]);
	        state.maxDepth += tokens[tokens.length - 1].depth;
	      }
	    }
	    state.slashes = slashes;
	    state.parts = parts;
	  }
	  return state;
	};
	scan_1 = scan;
	return scan_1;
}

var parse_1;
var hasRequiredParse;
function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;
	const constants = requireConstants();
	const utils = requireUtils$2();
	const {
	  MAX_LENGTH,
	  POSIX_REGEX_SOURCE,
	  REGEX_NON_SPECIAL_CHARS,
	  REGEX_SPECIAL_CHARS_BACKREF,
	  REPLACEMENTS
	} = constants;
	const expandRange = (args, options) => {
	  if (typeof options.expandRange === 'function') {
	    return options.expandRange(...args, options);
	  }
	  args.sort();
	  const value = `[${args.join('-')}]`;
	  try {
	    new RegExp(value);
	  } catch (ex) {
	    return args.map(v => utils.escapeRegex(v)).join('..');
	  }
	  return value;
	};
	const syntaxError = (type, char) => {
	  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
	};
	const parse = (input, options) => {
	  if (typeof input !== 'string') {
	    throw new TypeError('Expected a string');
	  }
	  input = REPLACEMENTS[input] || input;
	  const opts = { ...options };
	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
	  let len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }
	  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
	  const tokens = [bos];
	  const capture = opts.capture ? '' : '?:';
	  const win32 = utils.isWindows(options);
	  const PLATFORM_CHARS = constants.globChars(win32);
	  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
	  const {
	    DOT_LITERAL,
	    PLUS_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOT_SLASH,
	    NO_DOTS_SLASH,
	    QMARK,
	    QMARK_NO_DOT,
	    STAR,
	    START_ANCHOR
	  } = PLATFORM_CHARS;
	  const globstar = opts => {
	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };
	  const nodot = opts.dot ? '' : NO_DOT;
	  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
	  let star = opts.bash === true ? globstar(opts) : STAR;
	  if (opts.capture) {
	    star = `(${star})`;
	  }
	  if (typeof opts.noext === 'boolean') {
	    opts.noextglob = opts.noext;
	  }
	  const state = {
	    input,
	    index: -1,
	    start: 0,
	    dot: opts.dot === true,
	    consumed: '',
	    output: '',
	    prefix: '',
	    backtrack: false,
	    negated: false,
	    brackets: 0,
	    braces: 0,
	    parens: 0,
	    quotes: 0,
	    globstar: false,
	    tokens
	  };
	  input = utils.removePrefix(input, state);
	  len = input.length;
	  const extglobs = [];
	  const braces = [];
	  const stack = [];
	  let prev = bos;
	  let value;
	  const eos = () => state.index === len - 1;
	  const peek = state.peek = (n = 1) => input[state.index + n];
	  const advance = state.advance = () => input[++state.index] || '';
	  const remaining = () => input.slice(state.index + 1);
	  const consume = (value = '', num = 0) => {
	    state.consumed += value;
	    state.index += num;
	  };
	  const append = token => {
	    state.output += token.output != null ? token.output : token.value;
	    consume(token.value);
	  };
	  const negate = () => {
	    let count = 1;
	    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
	      advance();
	      state.start++;
	      count++;
	    }
	    if (count % 2 === 0) {
	      return false;
	    }
	    state.negated = true;
	    state.start++;
	    return true;
	  };
	  const increment = type => {
	    state[type]++;
	    stack.push(type);
	  };
	  const decrement = type => {
	    state[type]--;
	    stack.pop();
	  };
	  const push = tok => {
	    if (prev.type === 'globstar') {
	      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
	      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));
	      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
	        state.output = state.output.slice(0, -prev.output.length);
	        prev.type = 'star';
	        prev.value = '*';
	        prev.output = star;
	        state.output += prev.output;
	      }
	    }
	    if (extglobs.length && tok.type !== 'paren') {
	      extglobs[extglobs.length - 1].inner += tok.value;
	    }
	    if (tok.value || tok.output) append(tok);
	    if (prev && prev.type === 'text' && tok.type === 'text') {
	      prev.value += tok.value;
	      prev.output = (prev.output || '') + tok.value;
	      return;
	    }
	    tok.prev = prev;
	    tokens.push(tok);
	    prev = tok;
	  };
	  const extglobOpen = (type, value) => {
	    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };
	    token.prev = prev;
	    token.parens = state.parens;
	    token.output = state.output;
	    const output = (opts.capture ? '(' : '') + token.open;
	    increment('parens');
	    push({ type, value, output: state.output ? '' : ONE_CHAR });
	    push({ type: 'paren', extglob: true, value: advance(), output });
	    extglobs.push(token);
	  };
	  const extglobClose = token => {
	    let output = token.close + (opts.capture ? ')' : '');
	    let rest;
	    if (token.type === 'negate') {
	      let extglobStar = star;
	      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
	        extglobStar = globstar(opts);
	      }
	      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
	        output = token.close = `)$))${extglobStar}`;
	      }
	      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
	        const expression = parse(rest, { ...options, fastpaths: false }).output;
	        output = token.close = `)${expression})${extglobStar})`;
	      }
	      if (token.prev.type === 'bos') {
	        state.negatedExtglob = true;
	      }
	    }
	    push({ type: 'paren', extglob: true, value, output });
	    decrement('parens');
	  };
	  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
	    let backslashes = false;
	    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
	      if (first === '\\') {
	        backslashes = true;
	        return m;
	      }
	      if (first === '?') {
	        if (esc) {
	          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
	        }
	        if (index === 0) {
	          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
	        }
	        return QMARK.repeat(chars.length);
	      }
	      if (first === '.') {
	        return DOT_LITERAL.repeat(chars.length);
	      }
	      if (first === '*') {
	        if (esc) {
	          return esc + first + (rest ? star : '');
	        }
	        return star;
	      }
	      return esc ? m : `\\${m}`;
	    });
	    if (backslashes === true) {
	      if (opts.unescape === true) {
	        output = output.replace(/\\/g, '');
	      } else {
	        output = output.replace(/\\+/g, m => {
	          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
	        });
	      }
	    }
	    if (output === input && opts.contains === true) {
	      state.output = input;
	      return state;
	    }
	    state.output = utils.wrapOutput(output, state, options);
	    return state;
	  }
	  while (!eos()) {
	    value = advance();
	    if (value === '\u0000') {
	      continue;
	    }
	    if (value === '\\') {
	      const next = peek();
	      if (next === '/' && opts.bash !== true) {
	        continue;
	      }
	      if (next === '.' || next === ';') {
	        continue;
	      }
	      if (!next) {
	        value += '\\';
	        push({ type: 'text', value });
	        continue;
	      }
	      const match = /^\\+/.exec(remaining());
	      let slashes = 0;
	      if (match && match[0].length > 2) {
	        slashes = match[0].length;
	        state.index += slashes;
	        if (slashes % 2 !== 0) {
	          value += '\\';
	        }
	      }
	      if (opts.unescape === true) {
	        value = advance();
	      } else {
	        value += advance();
	      }
	      if (state.brackets === 0) {
	        push({ type: 'text', value });
	        continue;
	      }
	    }
	    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
	      if (opts.posix !== false && value === ':') {
	        const inner = prev.value.slice(1);
	        if (inner.includes('[')) {
	          prev.posix = true;
	          if (inner.includes(':')) {
	            const idx = prev.value.lastIndexOf('[');
	            const pre = prev.value.slice(0, idx);
	            const rest = prev.value.slice(idx + 2);
	            const posix = POSIX_REGEX_SOURCE[rest];
	            if (posix) {
	              prev.value = pre + posix;
	              state.backtrack = true;
	              advance();
	              if (!bos.output && tokens.indexOf(prev) === 1) {
	                bos.output = ONE_CHAR;
	              }
	              continue;
	            }
	          }
	        }
	      }
	      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
	        value = `\\${value}`;
	      }
	      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
	        value = `\\${value}`;
	      }
	      if (opts.posix === true && value === '!' && prev.value === '[') {
	        value = '^';
	      }
	      prev.value += value;
	      append({ value });
	      continue;
	    }
	    if (state.quotes === 1 && value !== '"') {
	      value = utils.escapeRegex(value);
	      prev.value += value;
	      append({ value });
	      continue;
	    }
	    if (value === '"') {
	      state.quotes = state.quotes === 1 ? 0 : 1;
	      if (opts.keepQuotes === true) {
	        push({ type: 'text', value });
	      }
	      continue;
	    }
	    if (value === '(') {
	      increment('parens');
	      push({ type: 'paren', value });
	      continue;
	    }
	    if (value === ')') {
	      if (state.parens === 0 && opts.strictBrackets === true) {
	        throw new SyntaxError(syntaxError('opening', '('));
	      }
	      const extglob = extglobs[extglobs.length - 1];
	      if (extglob && state.parens === extglob.parens + 1) {
	        extglobClose(extglobs.pop());
	        continue;
	      }
	      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
	      decrement('parens');
	      continue;
	    }
	    if (value === '[') {
	      if (opts.nobracket === true || !remaining().includes(']')) {
	        if (opts.nobracket !== true && opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError('closing', ']'));
	        }
	        value = `\\${value}`;
	      } else {
	        increment('brackets');
	      }
	      push({ type: 'bracket', value });
	      continue;
	    }
	    if (value === ']') {
	      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
	        push({ type: 'text', value, output: `\\${value}` });
	        continue;
	      }
	      if (state.brackets === 0) {
	        if (opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError('opening', '['));
	        }
	        push({ type: 'text', value, output: `\\${value}` });
	        continue;
	      }
	      decrement('brackets');
	      const prevValue = prev.value.slice(1);
	      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
	        value = `/${value}`;
	      }
	      prev.value += value;
	      append({ value });
	      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
	        continue;
	      }
	      const escaped = utils.escapeRegex(prev.value);
	      state.output = state.output.slice(0, -prev.value.length);
	      if (opts.literalBrackets === true) {
	        state.output += escaped;
	        prev.value = escaped;
	        continue;
	      }
	      prev.value = `(${capture}${escaped}|${prev.value})`;
	      state.output += prev.value;
	      continue;
	    }
	    if (value === '{' && opts.nobrace !== true) {
	      increment('braces');
	      const open = {
	        type: 'brace',
	        value,
	        output: '(',
	        outputIndex: state.output.length,
	        tokensIndex: state.tokens.length
	      };
	      braces.push(open);
	      push(open);
	      continue;
	    }
	    if (value === '}') {
	      const brace = braces[braces.length - 1];
	      if (opts.nobrace === true || !brace) {
	        push({ type: 'text', value, output: value });
	        continue;
	      }
	      let output = ')';
	      if (brace.dots === true) {
	        const arr = tokens.slice();
	        const range = [];
	        for (let i = arr.length - 1; i >= 0; i--) {
	          tokens.pop();
	          if (arr[i].type === 'brace') {
	            break;
	          }
	          if (arr[i].type !== 'dots') {
	            range.unshift(arr[i].value);
	          }
	        }
	        output = expandRange(range, opts);
	        state.backtrack = true;
	      }
	      if (brace.comma !== true && brace.dots !== true) {
	        const out = state.output.slice(0, brace.outputIndex);
	        const toks = state.tokens.slice(brace.tokensIndex);
	        brace.value = brace.output = '\\{';
	        value = output = '\\}';
	        state.output = out;
	        for (const t of toks) {
	          state.output += (t.output || t.value);
	        }
	      }
	      push({ type: 'brace', value, output });
	      decrement('braces');
	      braces.pop();
	      continue;
	    }
	    if (value === '|') {
	      if (extglobs.length > 0) {
	        extglobs[extglobs.length - 1].conditions++;
	      }
	      push({ type: 'text', value });
	      continue;
	    }
	    if (value === ',') {
	      let output = value;
	      const brace = braces[braces.length - 1];
	      if (brace && stack[stack.length - 1] === 'braces') {
	        brace.comma = true;
	        output = '|';
	      }
	      push({ type: 'comma', value, output });
	      continue;
	    }
	    if (value === '/') {
	      if (prev.type === 'dot' && state.index === state.start + 1) {
	        state.start = state.index + 1;
	        state.consumed = '';
	        state.output = '';
	        tokens.pop();
	        prev = bos;
	        continue;
	      }
	      push({ type: 'slash', value, output: SLASH_LITERAL });
	      continue;
	    }
	    if (value === '.') {
	      if (state.braces > 0 && prev.type === 'dot') {
	        if (prev.value === '.') prev.output = DOT_LITERAL;
	        const brace = braces[braces.length - 1];
	        prev.type = 'dots';
	        prev.output += value;
	        prev.value += value;
	        brace.dots = true;
	        continue;
	      }
	      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
	        push({ type: 'text', value, output: DOT_LITERAL });
	        continue;
	      }
	      push({ type: 'dot', value, output: DOT_LITERAL });
	      continue;
	    }
	    if (value === '?') {
	      const isGroup = prev && prev.value === '(';
	      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        extglobOpen('qmark', value);
	        continue;
	      }
	      if (prev && prev.type === 'paren') {
	        const next = peek();
	        let output = value;
	        if (next === '<' && !utils.supportsLookbehinds()) {
	          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
	        }
	        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
	          output = `\\${value}`;
	        }
	        push({ type: 'text', value, output });
	        continue;
	      }
	      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
	        push({ type: 'qmark', value, output: QMARK_NO_DOT });
	        continue;
	      }
	      push({ type: 'qmark', value, output: QMARK });
	      continue;
	    }
	    if (value === '!') {
	      if (opts.noextglob !== true && peek() === '(') {
	        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
	          extglobOpen('negate', value);
	          continue;
	        }
	      }
	      if (opts.nonegate !== true && state.index === 0) {
	        negate();
	        continue;
	      }
	    }
	    if (value === '+') {
	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        extglobOpen('plus', value);
	        continue;
	      }
	      if ((prev && prev.value === '(') || opts.regex === false) {
	        push({ type: 'plus', value, output: PLUS_LITERAL });
	        continue;
	      }
	      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
	        push({ type: 'plus', value });
	        continue;
	      }
	      push({ type: 'plus', value: PLUS_LITERAL });
	      continue;
	    }
	    if (value === '@') {
	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        push({ type: 'at', extglob: true, value, output: '' });
	        continue;
	      }
	      push({ type: 'text', value });
	      continue;
	    }
	    if (value !== '*') {
	      if (value === '$' || value === '^') {
	        value = `\\${value}`;
	      }
	      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
	      if (match) {
	        value += match[0];
	        state.index += match[0].length;
	      }
	      push({ type: 'text', value });
	      continue;
	    }
	    if (prev && (prev.type === 'globstar' || prev.star === true)) {
	      prev.type = 'star';
	      prev.star = true;
	      prev.value += value;
	      prev.output = star;
	      state.backtrack = true;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }
	    let rest = remaining();
	    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
	      extglobOpen('star', value);
	      continue;
	    }
	    if (prev.type === 'star') {
	      if (opts.noglobstar === true) {
	        consume(value);
	        continue;
	      }
	      const prior = prev.prev;
	      const before = prior.prev;
	      const isStart = prior.type === 'slash' || prior.type === 'bos';
	      const afterStar = before && (before.type === 'star' || before.type === 'globstar');
	      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
	        push({ type: 'star', value, output: '' });
	        continue;
	      }
	      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
	      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
	      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
	        push({ type: 'star', value, output: '' });
	        continue;
	      }
	      while (rest.slice(0, 3) === '/**') {
	        const after = input[state.index + 4];
	        if (after && after !== '/') {
	          break;
	        }
	        rest = rest.slice(3);
	        consume('/**', 3);
	      }
	      if (prior.type === 'bos' && eos()) {
	        prev.type = 'globstar';
	        prev.value += value;
	        prev.output = globstar(opts);
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value);
	        continue;
	      }
	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;
	        prev.type = 'globstar';
	        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
	        prev.value += value;
	        state.globstar = true;
	        state.output += prior.output + prev.output;
	        consume(value);
	        continue;
	      }
	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
	        const end = rest[1] !== void 0 ? '|$' : '';
	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;
	        prev.type = 'globstar';
	        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
	        prev.value += value;
	        state.output += prior.output + prev.output;
	        state.globstar = true;
	        consume(value + advance());
	        push({ type: 'slash', value: '/', output: '' });
	        continue;
	      }
	      if (prior.type === 'bos' && rest[0] === '/') {
	        prev.type = 'globstar';
	        prev.value += value;
	        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value + advance());
	        push({ type: 'slash', value: '/', output: '' });
	        continue;
	      }
	      state.output = state.output.slice(0, -prev.output.length);
	      prev.type = 'globstar';
	      prev.output = globstar(opts);
	      prev.value += value;
	      state.output += prev.output;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }
	    const token = { type: 'star', value, output: star };
	    if (opts.bash === true) {
	      token.output = '.*?';
	      if (prev.type === 'bos' || prev.type === 'slash') {
	        token.output = nodot + token.output;
	      }
	      push(token);
	      continue;
	    }
	    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
	      token.output = value;
	      push(token);
	      continue;
	    }
	    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
	      if (prev.type === 'dot') {
	        state.output += NO_DOT_SLASH;
	        prev.output += NO_DOT_SLASH;
	      } else if (opts.dot === true) {
	        state.output += NO_DOTS_SLASH;
	        prev.output += NO_DOTS_SLASH;
	      } else {
	        state.output += nodot;
	        prev.output += nodot;
	      }
	      if (peek() !== '*') {
	        state.output += ONE_CHAR;
	        prev.output += ONE_CHAR;
	      }
	    }
	    push(token);
	  }
	  while (state.brackets > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
	    state.output = utils.escapeLast(state.output, '[');
	    decrement('brackets');
	  }
	  while (state.parens > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
	    state.output = utils.escapeLast(state.output, '(');
	    decrement('parens');
	  }
	  while (state.braces > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
	    state.output = utils.escapeLast(state.output, '{');
	    decrement('braces');
	  }
	  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
	    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
	  }
	  if (state.backtrack === true) {
	    state.output = '';
	    for (const token of state.tokens) {
	      state.output += token.output != null ? token.output : token.value;
	      if (token.suffix) {
	        state.output += token.suffix;
	      }
	    }
	  }
	  return state;
	};
	parse.fastpaths = (input, options) => {
	  const opts = { ...options };
	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
	  const len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }
	  input = REPLACEMENTS[input] || input;
	  const win32 = utils.isWindows(options);
	  const {
	    DOT_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOTS,
	    NO_DOTS_SLASH,
	    STAR,
	    START_ANCHOR
	  } = constants.globChars(win32);
	  const nodot = opts.dot ? NO_DOTS : NO_DOT;
	  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
	  const capture = opts.capture ? '' : '?:';
	  const state = { negated: false, prefix: '' };
	  let star = opts.bash === true ? '.*?' : STAR;
	  if (opts.capture) {
	    star = `(${star})`;
	  }
	  const globstar = opts => {
	    if (opts.noglobstar === true) return star;
	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };
	  const create = str => {
	    switch (str) {
	      case '*':
	        return `${nodot}${ONE_CHAR}${star}`;
	      case '.*':
	        return `${DOT_LITERAL}${ONE_CHAR}${star}`;
	      case '*.*':
	        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
	      case '*/*':
	        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
	      case '**':
	        return nodot + globstar(opts);
	      case '**/*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
	      case '**/*.*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
	      case '**/.*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
	      default: {
	        const match = /^(.*?)\.(\w+)$/.exec(str);
	        if (!match) return;
	        const source = create(match[1]);
	        if (!source) return;
	        return source + DOT_LITERAL + match[2];
	      }
	    }
	  };
	  const output = utils.removePrefix(input, state);
	  let source = create(output);
	  if (source && opts.strictSlashes !== true) {
	    source += `${SLASH_LITERAL}?`;
	  }
	  return source;
	};
	parse_1 = parse;
	return parse_1;
}

var picomatch_1;
var hasRequiredPicomatch$1;
function requirePicomatch$1 () {
	if (hasRequiredPicomatch$1) return picomatch_1;
	hasRequiredPicomatch$1 = 1;
	const path = path$1;
	const scan = requireScan();
	const parse = requireParse();
	const utils = requireUtils$2();
	const constants = requireConstants();
	const isObject = val => val && typeof val === 'object' && !Array.isArray(val);
	const picomatch = (glob, options, returnState = false) => {
	  if (Array.isArray(glob)) {
	    const fns = glob.map(input => picomatch(input, options, returnState));
	    const arrayMatcher = str => {
	      for (const isMatch of fns) {
	        const state = isMatch(str);
	        if (state) return state;
	      }
	      return false;
	    };
	    return arrayMatcher;
	  }
	  const isState = isObject(glob) && glob.tokens && glob.input;
	  if (glob === '' || (typeof glob !== 'string' && !isState)) {
	    throw new TypeError('Expected pattern to be a non-empty string');
	  }
	  const opts = options || {};
	  const posix = utils.isWindows(options);
	  const regex = isState
	    ? picomatch.compileRe(glob, options)
	    : picomatch.makeRe(glob, options, false, true);
	  const state = regex.state;
	  delete regex.state;
	  let isIgnored = () => false;
	  if (opts.ignore) {
	    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
	    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
	  }
	  const matcher = (input, returnObject = false) => {
	    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
	    const result = { glob, state, regex, posix, input, output, match, isMatch };
	    if (typeof opts.onResult === 'function') {
	      opts.onResult(result);
	    }
	    if (isMatch === false) {
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }
	    if (isIgnored(input)) {
	      if (typeof opts.onIgnore === 'function') {
	        opts.onIgnore(result);
	      }
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }
	    if (typeof opts.onMatch === 'function') {
	      opts.onMatch(result);
	    }
	    return returnObject ? result : true;
	  };
	  if (returnState) {
	    matcher.state = state;
	  }
	  return matcher;
	};
	picomatch.test = (input, regex, options, { glob, posix } = {}) => {
	  if (typeof input !== 'string') {
	    throw new TypeError('Expected input to be a string');
	  }
	  if (input === '') {
	    return { isMatch: false, output: '' };
	  }
	  const opts = options || {};
	  const format = opts.format || (posix ? utils.toPosixSlashes : null);
	  let match = input === glob;
	  let output = (match && format) ? format(input) : input;
	  if (match === false) {
	    output = format ? format(input) : input;
	    match = output === glob;
	  }
	  if (match === false || opts.capture === true) {
	    if (opts.matchBase === true || opts.basename === true) {
	      match = picomatch.matchBase(input, regex, options, posix);
	    } else {
	      match = regex.exec(output);
	    }
	  }
	  return { isMatch: Boolean(match), match, output };
	};
	picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
	  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
	  return regex.test(path.basename(input));
	};
	picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
	picomatch.parse = (pattern, options) => {
	  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
	  return parse(pattern, { ...options, fastpaths: false });
	};
	picomatch.scan = (input, options) => scan(input, options);
	picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
	  if (returnOutput === true) {
	    return state.output;
	  }
	  const opts = options || {};
	  const prepend = opts.contains ? '' : '^';
	  const append = opts.contains ? '' : '$';
	  let source = `${prepend}(?:${state.output})${append}`;
	  if (state && state.negated === true) {
	    source = `^(?!${source}).*$`;
	  }
	  const regex = picomatch.toRegex(source, options);
	  if (returnState === true) {
	    regex.state = state;
	  }
	  return regex;
	};
	picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
	  if (!input || typeof input !== 'string') {
	    throw new TypeError('Expected a non-empty string');
	  }
	  let parsed = { negated: false, fastpaths: true };
	  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
	    parsed.output = parse.fastpaths(input, options);
	  }
	  if (!parsed.output) {
	    parsed = parse(input, options);
	  }
	  return picomatch.compileRe(parsed, options, returnOutput, returnState);
	};
	picomatch.toRegex = (source, options) => {
	  try {
	    const opts = options || {};
	    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
	  } catch (err) {
	    if (options && options.debug === true) throw err;
	    return /$^/;
	  }
	};
	picomatch.constants = constants;
	picomatch_1 = picomatch;
	return picomatch_1;
}

var picomatch;
var hasRequiredPicomatch;
function requirePicomatch () {
	if (hasRequiredPicomatch) return picomatch;
	hasRequiredPicomatch = 1;
	picomatch = requirePicomatch$1();
	return picomatch;
}

Object.defineProperty(builder, "__esModule", { value: true });
builder.Builder = void 0;
const path_1$e = path$1;
const api_builder_1 = apiBuilder;
var pm = null;
try {
    require.resolve("picomatch");
    pm = requirePicomatch();
}
catch (_e) {
}
class Builder {
    globCache = {};
    options = {
        maxDepth: Infinity,
        suppressErrors: true,
        pathSeparator: path_1$e.sep,
        filters: [],
    };
    constructor(options) {
        this.options = { ...this.options, ...options };
    }
    group() {
        this.options.group = true;
        return this;
    }
    withPathSeparator(separator) {
        this.options.pathSeparator = separator;
        return this;
    }
    withBasePath() {
        this.options.includeBasePath = true;
        return this;
    }
    withRelativePaths() {
        this.options.relativePaths = true;
        return this;
    }
    withDirs() {
        this.options.includeDirs = true;
        return this;
    }
    withMaxDepth(depth) {
        this.options.maxDepth = depth;
        return this;
    }
    withMaxFiles(limit) {
        this.options.maxFiles = limit;
        return this;
    }
    withFullPaths() {
        this.options.resolvePaths = true;
        this.options.includeBasePath = true;
        return this;
    }
    withErrors() {
        this.options.suppressErrors = false;
        return this;
    }
    withSymlinks() {
        this.options.resolveSymlinks = true;
        return this.withFullPaths();
    }
    withAbortSignal(signal) {
        this.options.signal = signal;
        return this;
    }
    normalize() {
        this.options.normalizePath = true;
        return this;
    }
    filter(predicate) {
        this.options.filters.push(predicate);
        return this;
    }
    onlyDirs() {
        this.options.excludeFiles = true;
        this.options.includeDirs = true;
        return this;
    }
    exclude(predicate) {
        this.options.exclude = predicate;
        return this;
    }
    onlyCounts() {
        this.options.onlyCounts = true;
        return this;
    }
    crawl(root) {
        return new api_builder_1.APIBuilder(root || ".", this.options);
    }
    crawlWithOptions(root, options) {
        this.options = { ...this.options, ...options };
        return new api_builder_1.APIBuilder(root || ".", this.options);
    }
    glob(...patterns) {
        return this.globWithOptions(patterns, { dot: true });
    }
    globWithOptions(patterns, options) {
        if (!pm) {
            throw new Error(`Please install picomatch: "npm i picomatch" to use glob matching.`);
        }
        var isMatch = this.globCache[patterns.join("\0")];
        if (!isMatch) {
            isMatch = pm(patterns, options);
            this.globCache[patterns.join("\0")] = isMatch;
        }
        this.options.filters.push((path) => isMatch(path));
        return this;
    }
}
builder.Builder = Builder;

var src$1 = {};

var types = {};

Object.defineProperty(types, "__esModule", { value: true });

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(types, exports);
} (src$1));
getDefaultExportFromCjs(src$1);

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fdir = void 0;
	const builder_1 = builder;
	Object.defineProperty(exports, "fdir", { enumerable: true, get: function () { return builder_1.Builder; } });
	__exportStar(src$1, exports);
} (dist));
getDefaultExportFromCjs(dist);

var src = {};

var server$1 = {};

var main$8 = {};

var is$4 = {};

Object.defineProperty(is$4, "__esModule", { value: true });
is$4.thenable = is$4.typedArray = is$4.stringArray = is$4.array = is$4.func = is$4.error = is$4.number = is$4.string = is$4.boolean = void 0;
function boolean$2(value) {
    return value === true || value === false;
}
is$4.boolean = boolean$2;
function string$2(value) {
    return typeof value === 'string' || value instanceof String;
}
is$4.string = string$2;
function number$2(value) {
    return typeof value === 'number' || value instanceof Number;
}
is$4.number = number$2;
function error$4(value) {
    return value instanceof Error;
}
is$4.error = error$4;
function func$2(value) {
    return typeof value === 'function';
}
is$4.func = func$2;
function array$2(value) {
    return Array.isArray(value);
}
is$4.array = array$2;
function stringArray$2(value) {
    return array$2(value) && value.every(elem => string$2(elem));
}
is$4.stringArray = stringArray$2;
function typedArray$2(value, check) {
    return Array.isArray(value) && value.every(check);
}
is$4.typedArray = typedArray$2;
function thenable(value) {
    return value && func$2(value.then);
}
is$4.thenable = thenable;

var server = {};

var main$7 = {};

var main$6 = {};

var ril$1 = {};

var api$4 = {};

var messages$3 = {};

var is$3 = {};

var hasRequiredIs$1;
function requireIs$1 () {
	if (hasRequiredIs$1) return is$3;
	hasRequiredIs$1 = 1;
	Object.defineProperty(is$3, "__esModule", { value: true });
	is$3.stringArray = is$3.array = is$3.func = is$3.error = is$3.number = is$3.string = is$3.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is$3.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is$3.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is$3.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is$3.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is$3.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is$3.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is$3.stringArray = stringArray;
	return is$3;
}

var hasRequiredMessages$1;
function requireMessages$1 () {
	if (hasRequiredMessages$1) return messages$3;
	hasRequiredMessages$1 = 1;
	Object.defineProperty(messages$3, "__esModule", { value: true });
	messages$3.Message = messages$3.NotificationType9 = messages$3.NotificationType8 = messages$3.NotificationType7 = messages$3.NotificationType6 = messages$3.NotificationType5 = messages$3.NotificationType4 = messages$3.NotificationType3 = messages$3.NotificationType2 = messages$3.NotificationType1 = messages$3.NotificationType0 = messages$3.NotificationType = messages$3.RequestType9 = messages$3.RequestType8 = messages$3.RequestType7 = messages$3.RequestType6 = messages$3.RequestType5 = messages$3.RequestType4 = messages$3.RequestType3 = messages$3.RequestType2 = messages$3.RequestType1 = messages$3.RequestType = messages$3.RequestType0 = messages$3.AbstractMessageSignature = messages$3.ParameterStructures = messages$3.ResponseError = messages$3.ErrorCodes = void 0;
	const is = requireIs$1();
	var ErrorCodes;
	(function (ErrorCodes) {
	    ErrorCodes.ParseError = -32700;
	    ErrorCodes.InvalidRequest = -32600;
	    ErrorCodes.MethodNotFound = -32601;
	    ErrorCodes.InvalidParams = -32602;
	    ErrorCodes.InternalError = -32603;
	    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
	    ErrorCodes.serverErrorStart = -32099;
	    ErrorCodes.MessageWriteError = -32099;
	    ErrorCodes.MessageReadError = -32098;
	    ErrorCodes.PendingResponseRejected = -32097;
	    ErrorCodes.ConnectionInactive = -32096;
	    ErrorCodes.ServerNotInitialized = -32002;
	    ErrorCodes.UnknownErrorCode = -32001;
	    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
	    ErrorCodes.serverErrorEnd = -32000;
	})(ErrorCodes || (messages$3.ErrorCodes = ErrorCodes = {}));
	class ResponseError extends Error {
	    constructor(code, message, data) {
	        super(message);
	        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
	        this.data = data;
	        Object.setPrototypeOf(this, ResponseError.prototype);
	    }
	    toJson() {
	        const result = {
	            code: this.code,
	            message: this.message
	        };
	        if (this.data !== undefined) {
	            result.data = this.data;
	        }
	        return result;
	    }
	}
	messages$3.ResponseError = ResponseError;
	class ParameterStructures {
	    constructor(kind) {
	        this.kind = kind;
	    }
	    static is(value) {
	        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
	    }
	    toString() {
	        return this.kind;
	    }
	}
	messages$3.ParameterStructures = ParameterStructures;
	ParameterStructures.auto = new ParameterStructures('auto');
	ParameterStructures.byPosition = new ParameterStructures('byPosition');
	ParameterStructures.byName = new ParameterStructures('byName');
	class AbstractMessageSignature {
	    constructor(method, numberOfParams) {
	        this.method = method;
	        this.numberOfParams = numberOfParams;
	    }
	    get parameterStructures() {
	        return ParameterStructures.auto;
	    }
	}
	messages$3.AbstractMessageSignature = AbstractMessageSignature;
	class RequestType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$3.RequestType0 = RequestType0;
	class RequestType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$3.RequestType = RequestType;
	class RequestType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$3.RequestType1 = RequestType1;
	class RequestType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$3.RequestType2 = RequestType2;
	class RequestType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$3.RequestType3 = RequestType3;
	class RequestType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$3.RequestType4 = RequestType4;
	class RequestType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$3.RequestType5 = RequestType5;
	class RequestType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$3.RequestType6 = RequestType6;
	class RequestType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$3.RequestType7 = RequestType7;
	class RequestType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$3.RequestType8 = RequestType8;
	class RequestType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$3.RequestType9 = RequestType9;
	class NotificationType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$3.NotificationType = NotificationType;
	class NotificationType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$3.NotificationType0 = NotificationType0;
	class NotificationType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$3.NotificationType1 = NotificationType1;
	class NotificationType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$3.NotificationType2 = NotificationType2;
	class NotificationType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$3.NotificationType3 = NotificationType3;
	class NotificationType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$3.NotificationType4 = NotificationType4;
	class NotificationType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$3.NotificationType5 = NotificationType5;
	class NotificationType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$3.NotificationType6 = NotificationType6;
	class NotificationType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$3.NotificationType7 = NotificationType7;
	class NotificationType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$3.NotificationType8 = NotificationType8;
	class NotificationType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$3.NotificationType9 = NotificationType9;
	var Message;
	(function (Message) {
	    function isRequest(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
	    }
	    Message.isRequest = isRequest;
	    function isNotification(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && message.id === void 0;
	    }
	    Message.isNotification = isNotification;
	    function isResponse(message) {
	        const candidate = message;
	        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
	    }
	    Message.isResponse = isResponse;
	})(Message || (messages$3.Message = Message = {}));
	return messages$3;
}

var linkedMap$1 = {};

var hasRequiredLinkedMap$1;
function requireLinkedMap$1 () {
	if (hasRequiredLinkedMap$1) return linkedMap$1;
	hasRequiredLinkedMap$1 = 1;
	var _a;
	Object.defineProperty(linkedMap$1, "__esModule", { value: true });
	linkedMap$1.LRUCache = linkedMap$1.LinkedMap = linkedMap$1.Touch = void 0;
	var Touch;
	(function (Touch) {
	    Touch.None = 0;
	    Touch.First = 1;
	    Touch.AsOld = Touch.First;
	    Touch.Last = 2;
	    Touch.AsNew = Touch.Last;
	})(Touch || (linkedMap$1.Touch = Touch = {}));
	class LinkedMap {
	    constructor() {
	        this[_a] = 'LinkedMap';
	        this._map = new Map();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state = 0;
	    }
	    clear() {
	        this._map.clear();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state++;
	    }
	    isEmpty() {
	        return !this._head && !this._tail;
	    }
	    get size() {
	        return this._size;
	    }
	    get first() {
	        return this._head?.value;
	    }
	    get last() {
	        return this._tail?.value;
	    }
	    has(key) {
	        return this._map.has(key);
	    }
	    get(key, touch = Touch.None) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        if (touch !== Touch.None) {
	            this.touch(item, touch);
	        }
	        return item.value;
	    }
	    set(key, value, touch = Touch.None) {
	        let item = this._map.get(key);
	        if (item) {
	            item.value = value;
	            if (touch !== Touch.None) {
	                this.touch(item, touch);
	            }
	        }
	        else {
	            item = { key, value, next: undefined, previous: undefined };
	            switch (touch) {
	                case Touch.None:
	                    this.addItemLast(item);
	                    break;
	                case Touch.First:
	                    this.addItemFirst(item);
	                    break;
	                case Touch.Last:
	                    this.addItemLast(item);
	                    break;
	                default:
	                    this.addItemLast(item);
	                    break;
	            }
	            this._map.set(key, item);
	            this._size++;
	        }
	        return this;
	    }
	    delete(key) {
	        return !!this.remove(key);
	    }
	    remove(key) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        this._map.delete(key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    shift() {
	        if (!this._head && !this._tail) {
	            return undefined;
	        }
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        const item = this._head;
	        this._map.delete(item.key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    forEach(callbackfn, thisArg) {
	        const state = this._state;
	        let current = this._head;
	        while (current) {
	            if (thisArg) {
	                callbackfn.bind(thisArg)(current.value, current.key, this);
	            }
	            else {
	                callbackfn(current.value, current.key, this);
	            }
	            if (this._state !== state) {
	                throw new Error(`LinkedMap got modified during iteration.`);
	            }
	            current = current.next;
	        }
	    }
	    keys() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.key, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    values() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.value, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    entries() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: [current.key, current.value], done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
	        return this.entries();
	    }
	    trimOld(newSize) {
	        if (newSize >= this.size) {
	            return;
	        }
	        if (newSize === 0) {
	            this.clear();
	            return;
	        }
	        let current = this._head;
	        let currentSize = this.size;
	        while (current && currentSize > newSize) {
	            this._map.delete(current.key);
	            current = current.next;
	            currentSize--;
	        }
	        this._head = current;
	        this._size = currentSize;
	        if (current) {
	            current.previous = undefined;
	        }
	        this._state++;
	    }
	    addItemFirst(item) {
	        if (!this._head && !this._tail) {
	            this._tail = item;
	        }
	        else if (!this._head) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.next = this._head;
	            this._head.previous = item;
	        }
	        this._head = item;
	        this._state++;
	    }
	    addItemLast(item) {
	        if (!this._head && !this._tail) {
	            this._head = item;
	        }
	        else if (!this._tail) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.previous = this._tail;
	            this._tail.next = item;
	        }
	        this._tail = item;
	        this._state++;
	    }
	    removeItem(item) {
	        if (item === this._head && item === this._tail) {
	            this._head = undefined;
	            this._tail = undefined;
	        }
	        else if (item === this._head) {
	            if (!item.next) {
	                throw new Error('Invalid list');
	            }
	            item.next.previous = undefined;
	            this._head = item.next;
	        }
	        else if (item === this._tail) {
	            if (!item.previous) {
	                throw new Error('Invalid list');
	            }
	            item.previous.next = undefined;
	            this._tail = item.previous;
	        }
	        else {
	            const next = item.next;
	            const previous = item.previous;
	            if (!next || !previous) {
	                throw new Error('Invalid list');
	            }
	            next.previous = previous;
	            previous.next = next;
	        }
	        item.next = undefined;
	        item.previous = undefined;
	        this._state++;
	    }
	    touch(item, touch) {
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        if ((touch !== Touch.First && touch !== Touch.Last)) {
	            return;
	        }
	        if (touch === Touch.First) {
	            if (item === this._head) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            if (item === this._tail) {
	                previous.next = undefined;
	                this._tail = previous;
	            }
	            else {
	                next.previous = previous;
	                previous.next = next;
	            }
	            item.previous = undefined;
	            item.next = this._head;
	            this._head.previous = item;
	            this._head = item;
	            this._state++;
	        }
	        else if (touch === Touch.Last) {
	            if (item === this._tail) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            if (item === this._head) {
	                next.previous = undefined;
	                this._head = next;
	            }
	            else {
	                next.previous = previous;
	                previous.next = next;
	            }
	            item.next = undefined;
	            item.previous = this._tail;
	            this._tail.next = item;
	            this._tail = item;
	            this._state++;
	        }
	    }
	    toJSON() {
	        const data = [];
	        this.forEach((value, key) => {
	            data.push([key, value]);
	        });
	        return data;
	    }
	    fromJSON(data) {
	        this.clear();
	        for (const [key, value] of data) {
	            this.set(key, value);
	        }
	    }
	}
	linkedMap$1.LinkedMap = LinkedMap;
	class LRUCache extends LinkedMap {
	    constructor(limit, ratio = 1) {
	        super();
	        this._limit = limit;
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	    }
	    get limit() {
	        return this._limit;
	    }
	    set limit(limit) {
	        this._limit = limit;
	        this.checkTrim();
	    }
	    get ratio() {
	        return this._ratio;
	    }
	    set ratio(ratio) {
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	        this.checkTrim();
	    }
	    get(key, touch = Touch.AsNew) {
	        return super.get(key, touch);
	    }
	    peek(key) {
	        return super.get(key, Touch.None);
	    }
	    set(key, value) {
	        super.set(key, value, Touch.Last);
	        this.checkTrim();
	        return this;
	    }
	    checkTrim() {
	        if (this.size > this._limit) {
	            this.trimOld(Math.round(this._limit * this._ratio));
	        }
	    }
	}
	linkedMap$1.LRUCache = LRUCache;
	return linkedMap$1;
}

var disposable$1 = {};

var hasRequiredDisposable;
function requireDisposable () {
	if (hasRequiredDisposable) return disposable$1;
	hasRequiredDisposable = 1;
	Object.defineProperty(disposable$1, "__esModule", { value: true });
	disposable$1.Disposable = void 0;
	var Disposable;
	(function (Disposable) {
	    function create(func) {
	        return {
	            dispose: func
	        };
	    }
	    Disposable.create = create;
	})(Disposable || (disposable$1.Disposable = Disposable = {}));
	return disposable$1;
}

var events$1 = {};

var ral$2 = {};

var hasRequiredRal;
function requireRal () {
	if (hasRequiredRal) return ral$2;
	hasRequiredRal = 1;
	Object.defineProperty(ral$2, "__esModule", { value: true });
	let _ral;
	function RAL() {
	    if (_ral === undefined) {
	        throw new Error(`No runtime abstraction layer installed`);
	    }
	    return _ral;
	}
	(function (RAL) {
	    function install(ral) {
	        if (ral === undefined) {
	            throw new Error(`No runtime abstraction layer provided`);
	        }
	        _ral = ral;
	    }
	    RAL.install = install;
	})(RAL || (RAL = {}));
	ral$2.default = RAL;
	return ral$2;
}

var hasRequiredEvents$1;
function requireEvents$1 () {
	if (hasRequiredEvents$1) return events$1;
	hasRequiredEvents$1 = 1;
	Object.defineProperty(events$1, "__esModule", { value: true });
	events$1.Emitter = events$1.Event = void 0;
	const ral_1 = requireRal();
	var Event;
	(function (Event) {
	    const _disposable = { dispose() { } };
	    Event.None = function () { return _disposable; };
	})(Event || (events$1.Event = Event = {}));
	class CallbackList {
	    add(callback, context = null, bucket) {
	        if (!this._callbacks) {
	            this._callbacks = [];
	            this._contexts = [];
	        }
	        this._callbacks.push(callback);
	        this._contexts.push(context);
	        if (Array.isArray(bucket)) {
	            bucket.push({ dispose: () => this.remove(callback, context) });
	        }
	    }
	    remove(callback, context = null) {
	        if (!this._callbacks) {
	            return;
	        }
	        let foundCallbackWithDifferentContext = false;
	        for (let i = 0, len = this._callbacks.length; i < len; i++) {
	            if (this._callbacks[i] === callback) {
	                if (this._contexts[i] === context) {
	                    this._callbacks.splice(i, 1);
	                    this._contexts.splice(i, 1);
	                    return;
	                }
	                else {
	                    foundCallbackWithDifferentContext = true;
	                }
	            }
	        }
	        if (foundCallbackWithDifferentContext) {
	            throw new Error('When adding a listener with a context, you should remove it with the same context');
	        }
	    }
	    invoke(...args) {
	        if (!this._callbacks) {
	            return [];
	        }
	        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
	        for (let i = 0, len = callbacks.length; i < len; i++) {
	            try {
	                ret.push(callbacks[i].apply(contexts[i], args));
	            }
	            catch (e) {
	                (0, ral_1.default)().console.error(e);
	            }
	        }
	        return ret;
	    }
	    isEmpty() {
	        return !this._callbacks || this._callbacks.length === 0;
	    }
	    dispose() {
	        this._callbacks = undefined;
	        this._contexts = undefined;
	    }
	}
	class Emitter {
	    constructor(_options) {
	        this._options = _options;
	    }
	    get event() {
	        if (!this._event) {
	            this._event = (listener, thisArgs, disposables) => {
	                if (!this._callbacks) {
	                    this._callbacks = new CallbackList();
	                }
	                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
	                    this._options.onFirstListenerAdd(this);
	                }
	                this._callbacks.add(listener, thisArgs);
	                const result = {
	                    dispose: () => {
	                        if (!this._callbacks) {
	                            return;
	                        }
	                        this._callbacks.remove(listener, thisArgs);
	                        result.dispose = Emitter._noop;
	                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
	                            this._options.onLastListenerRemove(this);
	                        }
	                    }
	                };
	                if (Array.isArray(disposables)) {
	                    disposables.push(result);
	                }
	                return result;
	            };
	        }
	        return this._event;
	    }
	    fire(event) {
	        if (this._callbacks) {
	            this._callbacks.invoke.call(this._callbacks, event);
	        }
	    }
	    dispose() {
	        if (this._callbacks) {
	            this._callbacks.dispose();
	            this._callbacks = undefined;
	        }
	    }
	}
	events$1.Emitter = Emitter;
	Emitter._noop = function () { };
	return events$1;
}

var cancellation$1 = {};

var hasRequiredCancellation$1;
function requireCancellation$1 () {
	if (hasRequiredCancellation$1) return cancellation$1;
	hasRequiredCancellation$1 = 1;
	Object.defineProperty(cancellation$1, "__esModule", { value: true });
	cancellation$1.CancellationTokenSource = cancellation$1.CancellationToken = void 0;
	const ral_1 = requireRal();
	const Is = requireIs$1();
	const events_1 = requireEvents$1();
	var CancellationToken;
	(function (CancellationToken) {
	    CancellationToken.None = Object.freeze({
	        isCancellationRequested: false,
	        onCancellationRequested: events_1.Event.None
	    });
	    CancellationToken.Cancelled = Object.freeze({
	        isCancellationRequested: true,
	        onCancellationRequested: events_1.Event.None
	    });
	    function is(value) {
	        const candidate = value;
	        return candidate && (candidate === CancellationToken.None
	            || candidate === CancellationToken.Cancelled
	            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
	    }
	    CancellationToken.is = is;
	})(CancellationToken || (cancellation$1.CancellationToken = CancellationToken = {}));
	const shortcutEvent = Object.freeze(function (callback, context) {
	    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
	    return { dispose() { handle.dispose(); } };
	});
	class MutableToken {
	    constructor() {
	        this._isCancelled = false;
	    }
	    cancel() {
	        if (!this._isCancelled) {
	            this._isCancelled = true;
	            if (this._emitter) {
	                this._emitter.fire(undefined);
	                this.dispose();
	            }
	        }
	    }
	    get isCancellationRequested() {
	        return this._isCancelled;
	    }
	    get onCancellationRequested() {
	        if (this._isCancelled) {
	            return shortcutEvent;
	        }
	        if (!this._emitter) {
	            this._emitter = new events_1.Emitter();
	        }
	        return this._emitter.event;
	    }
	    dispose() {
	        if (this._emitter) {
	            this._emitter.dispose();
	            this._emitter = undefined;
	        }
	    }
	}
	class CancellationTokenSource {
	    get token() {
	        if (!this._token) {
	            this._token = new MutableToken();
	        }
	        return this._token;
	    }
	    cancel() {
	        if (!this._token) {
	            this._token = CancellationToken.Cancelled;
	        }
	        else {
	            this._token.cancel();
	        }
	    }
	    dispose() {
	        if (!this._token) {
	            this._token = CancellationToken.None;
	        }
	        else if (this._token instanceof MutableToken) {
	            this._token.dispose();
	        }
	    }
	}
	cancellation$1.CancellationTokenSource = CancellationTokenSource;
	return cancellation$1;
}

var sharedArrayCancellation = {};

var hasRequiredSharedArrayCancellation;
function requireSharedArrayCancellation () {
	if (hasRequiredSharedArrayCancellation) return sharedArrayCancellation;
	hasRequiredSharedArrayCancellation = 1;
	Object.defineProperty(sharedArrayCancellation, "__esModule", { value: true });
	sharedArrayCancellation.SharedArrayReceiverStrategy = sharedArrayCancellation.SharedArraySenderStrategy = void 0;
	const cancellation_1 = requireCancellation$1();
	var CancellationState;
	(function (CancellationState) {
	    CancellationState.Continue = 0;
	    CancellationState.Cancelled = 1;
	})(CancellationState || (CancellationState = {}));
	class SharedArraySenderStrategy {
	    constructor() {
	        this.buffers = new Map();
	    }
	    enableCancellation(request) {
	        if (request.id === null) {
	            return;
	        }
	        const buffer = new SharedArrayBuffer(4);
	        const data = new Int32Array(buffer, 0, 1);
	        data[0] = CancellationState.Continue;
	        this.buffers.set(request.id, buffer);
	        request.$cancellationData = buffer;
	    }
	    async sendCancellation(_conn, id) {
	        const buffer = this.buffers.get(id);
	        if (buffer === undefined) {
	            return;
	        }
	        const data = new Int32Array(buffer, 0, 1);
	        Atomics.store(data, 0, CancellationState.Cancelled);
	    }
	    cleanup(id) {
	        this.buffers.delete(id);
	    }
	    dispose() {
	        this.buffers.clear();
	    }
	}
	sharedArrayCancellation.SharedArraySenderStrategy = SharedArraySenderStrategy;
	class SharedArrayBufferCancellationToken {
	    constructor(buffer) {
	        this.data = new Int32Array(buffer, 0, 1);
	    }
	    get isCancellationRequested() {
	        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
	    }
	    get onCancellationRequested() {
	        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
	    }
	}
	class SharedArrayBufferCancellationTokenSource {
	    constructor(buffer) {
	        this.token = new SharedArrayBufferCancellationToken(buffer);
	    }
	    cancel() {
	    }
	    dispose() {
	    }
	}
	class SharedArrayReceiverStrategy {
	    constructor() {
	        this.kind = 'request';
	    }
	    createCancellationTokenSource(request) {
	        const buffer = request.$cancellationData;
	        if (buffer === undefined) {
	            return new cancellation_1.CancellationTokenSource();
	        }
	        return new SharedArrayBufferCancellationTokenSource(buffer);
	    }
	}
	sharedArrayCancellation.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
	return sharedArrayCancellation;
}